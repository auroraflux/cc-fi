"""Parse Claude Code session JSONL files."""

import json
from datetime import datetime
from pathlib import Path


def extract_project_name(cwd: str) -> str:
    """
    Extract project name from working directory path.

    @param cwd Working directory path
    @returns Last component of path (project name)
    @complexity O(1)
    @pure true
    """
    return Path(cwd).name


def extract_session_id_from_filename(file_path: Path) -> str:
    """
    Extract session ID from .jsonl filename.

    Claude Code uses the filename (not content's sessionId field) for resuming.
    Some files have mismatched session IDs between filename and content.

    @param file_path Path to session file
    @returns Session ID extracted from filename (without .jsonl extension)
    @complexity O(1)
    @pure true
    """
    return file_path.stem  # filename without extension


def is_boilerplate_message(text: str) -> bool:
    """
    Check if message is Claude Code boilerplate (continuation or commands).

    Uses centralized filter registry for pattern matching.

    @param text Message text to check
    @returns True if message is boilerplate
    @complexity O(n) where n is number of patterns
    @pure true
    """
    from cc_fi.core.filters import is_boilerplate

    return is_boilerplate(text)


def extract_text_from_content(content) -> str:
    """
    Extract text from message content (handles both old and new formats).

    @param content Message content (string or list of content blocks)
    @returns Extracted text string
    @complexity O(n) where n is number of content blocks
    @pure true
    """
    if isinstance(content, str):
        return content

    if isinstance(content, list):
        text_parts = []
        for item in content:
            if isinstance(item, dict) and item.get("type") == "text":
                text_parts.append(item.get("text", ""))
        return " ".join(text_parts)

    return ""


def is_tool_result_message(data: dict) -> bool:
    """
    Check if a user message contains only tool results (no actual user text).

    Tool result messages are generated by Claude Code when tools execute,
    and should not be treated as "the user's last message."

    @param data Message data dictionary from JSONL
    @returns True if ALL content blocks are tool_result type
    @complexity O(n) where n is number of content blocks
    @pure true
    """
    message = data.get("message", {})
    content = message.get("content", [])

    # If not a list or empty, not a pure tool result
    if not isinstance(content, list) or not content:
        return False

    # Check if ALL blocks are tool_result type
    return all(
        isinstance(block, dict) and block.get("type") == "tool_result"
        for block in content
    )


def extract_all_user_messages(file_path: Path) -> str:
    """
    Extract all user messages from session for deep search.

    Excludes:
    - Tool result messages
    - Boilerplate messages (continuations, commands)
    - Assistant messages

    Messages are joined with " | " separator for fzf deep search.
    Newlines are replaced with spaces to keep content on single line.

    @param file_path Path to session JSONL file
    @returns All user messages joined with " | " separator (single line)
    @complexity O(n) where n is lines in session file
    @pure false - reads filesystem
    """
    messages = []

    try:
        with file_path.open("r", encoding="utf-8") as f:
            for line in f:
                if not line.strip():
                    continue

                try:
                    data = json.loads(line)
                except json.JSONDecodeError:
                    continue

                # Only process user messages
                if data.get("type") != "user":
                    continue

                # Skip tool results
                if is_tool_result_message(data):
                    continue

                # Extract text content
                message = data.get("message", {})
                content = message.get("content", "")
                text = extract_text_from_content(content)

                # Skip boilerplate
                if is_boilerplate_message(text):
                    continue

                # Skip empty messages
                if not text.strip():
                    continue

                # Replace newlines with spaces for single-line fzf display
                text_single_line = " ".join(text.split())
                messages.append(text_single_line)

    except (FileNotFoundError, PermissionError):
        return ""

    return " | ".join(messages)


def parse_first_user_message(file_path: Path) -> tuple[dict, str]:
    """
    Parse first real user message from JSONL file, skipping tool results and boilerplate.

    @param file_path Path to session file
    @returns Tuple of (first_user_data, message_content)
    @throws FileNotFoundError When file doesn't exist
    @throws json.JSONDecodeError When malformed JSON
    @throws ValueError When no user messages found
    @complexity O(n) worst case - reads until first user message
    @pure false - reads filesystem
    """
    first_found = None

    with file_path.open("r", encoding="utf-8") as f:
        for line in f:
            if not line.strip():
                continue

            try:
                data = json.loads(line)
                if data.get("type") == "user":
                    # Skip tool result messages
                    if is_tool_result_message(data):
                        continue

                    message = data.get("message", {})
                    content = message.get("content", "")
                    text = extract_text_from_content(content)

                    # Save first user message as fallback
                    if first_found is None:
                        first_found = (data, text)

                    # Skip boilerplate messages, keep looking
                    if is_boilerplate_message(text):
                        continue

                    # Found a real user message
                    return data, text

            except json.JSONDecodeError:
                continue

    # Return first message found, even if it's boilerplate
    if first_found:
        return first_found

    raise ValueError(f"No user messages found in: {file_path}")


def parse_last_user_message(file_path: Path, max_lines: int) -> str:
    """
    Parse last user message from JSONL file, skipping tool results and boilerplate.

    @param file_path Path to session file
    @param max_lines Maximum lines to read from end
    @returns Last user message content (empty if only tool results/boilerplate found)
    @complexity O(n) where n is max_lines
    @pure false - reads filesystem
    """
    from cc_fi.constants import MAX_TAIL_LINES_FOR_LAST_MSG

    with file_path.open("r", encoding="utf-8") as f:
        lines = f.readlines()

    tail_lines = lines[-max_lines:] if len(lines) > max_lines else lines

    for line in reversed(tail_lines):
        try:
            data = json.loads(line)
            if data.get("type") == "user":
                # Skip tool result messages
                if is_tool_result_message(data):
                    continue

                content = data.get("message", {}).get("content", "")
                text = extract_text_from_content(content)

                # Skip boilerplate messages
                if is_boilerplate_message(text):
                    continue

                return text
        except json.JSONDecodeError:
            continue

    return ""


def count_messages(file_path: Path) -> int:
    """
    Count total messages in session file.

    @param file_path Path to session file
    @returns Number of lines (messages) in file
    @complexity O(1) - uses wc-like approach
    @pure false - reads filesystem
    """
    with file_path.open("r", encoding="utf-8") as f:
        return sum(1 for _ in f)


def extract_metadata_from_file(file_path: Path) -> "SessionData":
    """
    Extract all metadata from a Claude Code session file.

    @param file_path Path to .jsonl session file
    @returns SessionData with extracted metadata
    @throws FileNotFoundError When file doesn't exist
    @throws json.JSONDecodeError When malformed JSON
    @throws KeyError When required fields missing

    @complexity O(n) where n is lines in file
    @pure false - reads filesystem
    """
    from cc_fi.constants import MAX_TAIL_LINES_FOR_LAST_MSG
    from cc_fi.models.session import SessionData

    first_data, first_msg = parse_first_user_message(file_path)

    # Extract session ID from filename (not content) since Claude Code uses filename for resuming
    session_id = extract_session_id_from_filename(file_path)
    cwd = first_data["cwd"]
    project_name = extract_project_name(cwd)
    git_branch = first_data.get("gitBranch", "")
    timestamp_str = first_data["timestamp"]
    timestamp = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))

    last_msg = parse_last_user_message(file_path, MAX_TAIL_LINES_FOR_LAST_MSG)
    msg_count = count_messages(file_path)
    last_modified = file_path.stat().st_mtime

    # Extract all user messages for deep search
    full_content = extract_all_user_messages(file_path)

    # Create both truncated (for table) and full (for preview) versions
    from cc_fi.constants import MESSAGE_PREVIEW_LENGTH, MESSAGE_DETAIL_LENGTH

    # Table display: 60 char truncation
    first_msg_preview = first_msg[:MESSAGE_PREVIEW_LENGTH] if len(first_msg) > MESSAGE_PREVIEW_LENGTH else first_msg
    last_msg_preview = last_msg[:MESSAGE_PREVIEW_LENGTH] if len(last_msg) > MESSAGE_PREVIEW_LENGTH else last_msg

    # Preview display: 400 char truncation
    first_msg_full = first_msg[:MESSAGE_DETAIL_LENGTH] if len(first_msg) > MESSAGE_DETAIL_LENGTH else first_msg
    last_msg_full = last_msg[:MESSAGE_DETAIL_LENGTH] if len(last_msg) > MESSAGE_DETAIL_LENGTH else last_msg

    return SessionData(
        session_id=session_id,
        cwd=cwd,
        project_name=project_name,
        git_branch=git_branch,
        timestamp=timestamp,
        first_message=first_msg_preview,
        last_message=last_msg_preview,
        message_count=msg_count,
        file_path=file_path,
        last_modified=last_modified,
        first_message_full=first_msg_full,
        last_message_full=last_msg_full,
        full_content=full_content,
    )
